<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROTOCOL: VOID</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    
    <style>
        :root {
            --bg-color: #050505;
            --terminal-green: #33ff33;
            --terminal-red: #ff3333;
            --terminal-amber: #ffcc00;
            --terminal-cyan: #00ccff;
            --terminal-dim: #444;
        }

        body {
            background-color: var(--bg-color);
            color: #e0e0e0;
            font-family: 'Fira Code', monospace;
            overflow: hidden;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Dynamic viewport height for mobile browsers */
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        /* FX Layers */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 50;
            opacity: 0.6;
        }
        
        .flicker {
            animation: flicker 0.15s infinite;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(18, 16, 16, 0.05);
            pointer-events: none;
            z-index: 49;
        }

        .glow-text { text-shadow: 0 0 4px currentColor; }
        
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Text Utilities */
        .txt-sys { color: #888; }
        .txt-success { color: var(--terminal-green); text-shadow: 0 0 5px rgba(51, 255, 51, 0.5); }
        .txt-error { color: var(--terminal-red); text-shadow: 0 0 5px rgba(255, 51, 51, 0.5); }
        .txt-warn { color: var(--terminal-amber); text-shadow: 0 0 5px rgba(255, 204, 0, 0.5); }
        .txt-item { color: var(--terminal-cyan); text-shadow: 0 0 5px rgba(0, 204, 255, 0.5); }
        .txt-nav { color: #d4d4d4; font-weight: bold; }
        .txt-choice { color: #fff; cursor: pointer; }
        .txt-choice:hover { text-decoration: underline; color: var(--terminal-green); }

        #output p { margin-bottom: 0.5rem; line-height: 1.4; }

        /* Map Styles */
        .map-cell { transition: all 0.3s ease; border: 1px solid #222; background: #0a0a0a; }
        .map-cell.active {
            border-color: var(--terminal-green);
            background-color: rgba(51, 255, 51, 0.1);
            color: var(--terminal-green);
            box-shadow: 0 0 8px rgba(51, 255, 51, 0.2);
        }

        /* Landing Page */
        #landing-page {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        
        /* Game Over Page */
        #game-over-page {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #050505;
            z-index: 101; /* Above landing page */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            opacity: 0;
            transition: opacity 1s ease-in;
        }
        #game-over-page.visible { opacity: 1; }
        
        .boot-btn {
            border: 1px solid var(--terminal-green);
            color: var(--terminal-green);
            padding: 10px 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 2rem;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0,0,0,0.5);
        }
        .boot-btn:hover { background: var(--terminal-green); color: black; box-shadow: 0 0 15px var(--terminal-green); }

        .hidden { display: none !important; }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="flex flex-col md:flex-row h-screen max-w-7xl mx-auto border-x-0 md:border-x border-gray-800 shadow-2xl shadow-black relative overflow-hidden">

    <div class="scanlines"></div>
    <div class="flicker"></div>

    <!-- START SCREEN -->
    <div id="landing-page">
        <div class="max-w-2xl w-full">
            <h1 class="text-3xl md:text-6xl text-green-500 font-bold mb-6 md:mb-8 text-center glow-text tracking-widest break-words">PROTOCOL:<span class="text-red-500 ml-2 md:ml-4">VOID</span></h1>
            <div id="boot-text" class="font-mono text-xs md:text-base text-gray-400 space-y-2 md:space-y-4 h-48 md:h-64 overflow-hidden border-l-2 border-green-900 pl-4">
                <!-- Typewriter intro goes here -->
            </div>
            <div class="text-center">
                <button id="start-btn" class="boot-btn opacity-0 text-sm md:text-base">Initialize Link</button>
            </div>
        </div>
    </div>
    
    <!-- GAME OVER SCREEN -->
    <div id="game-over-page" class="hidden">
        <div class="max-w-3xl w-full text-center">
            <h1 class="text-2xl md:text-4xl text-gray-500 font-bold mb-2 tracking-widest">FINAL REPORT</h1>
            <div id="end-rating" class="text-6xl md:text-9xl font-bold mb-8 glow-text">RANK: ?</div>
            <div id="end-message" class="text-sm md:text-xl font-mono text-gray-300 mb-8 max-w-lg mx-auto leading-relaxed border-l-2 border-gray-700 pl-6 text-left"></div>
            <button id="restart-btn" class="boot-btn">SYSTEM RESET</button>
        </div>
    </div>

    <!-- GAME UI -->
    <!-- Sidebar -->
    <aside class="w-full md:w-80 bg-black border-b md:border-b-0 md:border-r border-gray-800 flex flex-col flex-shrink-0 p-3 md:p-4 z-10 font-bold tracking-wider relative h-auto max-h-[40vh] md:max-h-full md:h-full overflow-hidden md:overflow-visible">
        
        <!-- Header -->
        <div class="flex justify-between items-end border-b border-gray-800 pb-2 mb-2 flex-shrink-0">
            <div>
                <h1 class="text-base md:text-lg text-green-500 glow-text">PROTOCOL:<span class="text-red-500 ml-1">VOID</span></h1>
                <div class="text-[10px] text-gray-500">SESSION ID: <span id="session-id">8492-X</span></div>
            </div>
            <div class="text-[10px] md:text-xs text-red-500 animate-pulse">LOCKDOWN ACTIVE</div>
        </div>

        <!-- Sidebar Scroll Container for Mobile -->
        <div class="flex-grow flex flex-col md:flex-col overflow-y-auto md:overflow-visible">
            
            <!-- Minimap -->
            <div class="mb-2 md:mb-4 flex-shrink-0">
                <h2 class="text-[10px] uppercase text-gray-500 mb-1 md:mb-2">Sector Map</h2>
                <!-- Map Grid: 5x5 grid - Main Hall is central hub, rooms positioned by actual connections -->
                <!-- Layout: Main Hall (row 3, col 3) is center. Rooms positioned relative to their connections -->
                <div class="grid grid-cols-5 gap-1 mb-2 font-mono text-[8px] md:text-[9px] text-center select-none max-w-[250px] md:max-w-none mx-auto md:mx-0">
                    <!-- Row 1: North area - Security (NW), Comm Hub (N of Research), Server (N), Medical (NE), Quarters (E of Medical) -->
                    <div id="map-security_office" class="map-cell p-1 text-gray-600 rounded" title="Security Office (NW of Main Hall)">SEC</div>
                    <div id="map-communications_hub" class="map-cell p-1 text-gray-600 rounded" title="Communications Hub (E of Security, N of Research Lab)">COMM</div>
                    <div id="map-server_room" class="map-cell p-1 text-gray-600 rounded" title="Server Room (N of Main Hall)">SERVER</div>
                    <div id="map-medical_bay" class="map-cell p-1 text-gray-600 rounded" title="Medical Bay (NE of Main Hall)">MED</div>
                    <div id="map-quarters" class="map-cell p-1 text-gray-600 rounded" title="Quarters (E of Medical Bay)">QTRS</div>
                    <!-- Row 2: Research Lab (N of Comm Hub, positioned between Comm Hub and Main Hall area) -->
                    <div></div>
                    <div id="map-research_lab" class="map-cell p-1 text-gray-600 rounded" title="Research Lab (S of Comm Hub, W of Main Hall)">LAB</div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <!-- Row 3: Central row - Engineering (W), Main Hall (center), Cryo (E) -->
                    <div id="map-engineering" class="map-cell p-1 text-gray-600 rounded" title="Engineering (W of Main Hall)">ENG</div>
                    <div></div>
                    <div id="map-main_hall" class="map-cell p-1 text-gray-600 rounded" title="Main Hall (Central Hub)">MAIN</div>
                    <div></div>
                    <div id="map-cryo_bay" class="map-cell p-1 text-gray-600 rounded" title="Cryo Bay (E of Main Hall)">CRYO</div>
                    <!-- Row 4: Empty -->
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                    <!-- Row 5: Docking Bay (S of Main Hall) -->
                    <div></div>
                    <div></div>
                    <div id="map-docking_bay" class="map-cell p-1 text-gray-600 rounded" title="Docking Bay (S of Main Hall)">DOCK</div>
                    <div></div>
                    <div></div>
                </div>
                <div class="flex justify-between text-[10px] bg-gray-900 p-1 rounded max-w-[200px] md:max-w-none mx-auto md:mx-0">
                    <span class="text-gray-400">LOC: <span id="status-loc" class="text-cyan-400">UNKNOWN</span></span>
                    <span class="text-gray-400">TURN: <span id="status-turn" class="text-yellow-500">0</span></span>
                </div>
            </div>

            <!-- Two Column Info (Side by side on mobile, stacked on desktop) -->
            <div class="flex-grow flex flex-row md:flex-col gap-2 md:gap-4 min-h-[100px] md:min-h-0">
                <!-- Inventory -->
                <div class="w-1/2 md:w-full flex flex-col overflow-hidden border border-gray-900 p-2 rounded">
                    <h2 class="text-[10px] uppercase text-gray-500 mb-1 bg-black shrink-0">Inventory</h2>
                    <ul id="inventory-list" class="text-[10px] md:text-xs space-y-1 text-cyan-600 overflow-y-auto">
                        <li class="italic text-gray-700 opacity-50">Empty...</li>
                    </ul>
                </div>

                <!-- Documentation System -->
                <div class="w-1/2 md:w-full flex flex-col overflow-hidden border border-gray-900 p-2 rounded bg-gray-900/20">
                    <!-- Tabs -->
                    <div class="flex gap-1 mb-1 border-b border-gray-800 shrink-0">
                        <button class="doc-tab active text-[9px] px-2 py-1 bg-gray-800 text-amber-500" data-tab="characters">CHARS</button>
                        <button class="doc-tab text-[9px] px-2 py-1 text-gray-600 hover:text-amber-500" data-tab="evidence">EVID</button>
                        <button class="doc-tab text-[9px] px-2 py-1 text-gray-600 hover:text-amber-500" data-tab="scenes">SCENES</button>
                        <button class="doc-tab text-[9px] px-2 py-1 text-gray-600 hover:text-amber-500" data-tab="notes">NOTES</button>
                    </div>
                    <!-- Content Areas -->
                    <div id="doc-characters" class="doc-content text-[10px] md:text-xs space-y-2 text-gray-400 font-normal overflow-y-auto">
                        <div class="italic opacity-30">No characters documented yet.</div>
                    </div>
                    <div id="doc-evidence" class="doc-content hidden text-[10px] md:text-xs space-y-2 text-gray-400 font-normal overflow-y-auto">
                        <div class="italic opacity-30">No evidence documented yet.</div>
                    </div>
                    <div id="doc-scenes" class="doc-content hidden text-[10px] md:text-xs space-y-2 text-gray-400 font-normal overflow-y-auto">
                        <div class="italic opacity-30">No scenes documented yet.</div>
                    </div>
                    <div id="doc-notes" class="doc-content hidden text-[10px] md:text-xs space-y-2 text-gray-400 font-normal overflow-y-auto">
                        <div class="italic opacity-30">No data recorded.</div>
                    </div>
                </div>
            </div>

            <div class="mt-2 md:mt-4 pt-2 border-t border-gray-800 flex-shrink-0">
                <div class="flex items-center justify-between">
                    <span class="text-gray-600 text-[10px]">EVIDENCE CHAIN</span>
                    <span id="evidence-count" class="text-lg md:text-xl text-red-500 font-mono glow-text">0/20</span>
                </div>
            </div>
        </div>
    </aside>

    <!-- Main Console -->
    <main class="flex-1 flex flex-col bg-opacity-95 bg-black z-10 relative overflow-hidden min-h-0">
        <!-- Output Log -->
        <div id="console-output" class="flex-grow overflow-y-auto p-3 md:p-6 font-mono text-sm md:text-base pb-4">
            <!-- Dynamic Content -->
        </div>

        <!-- Input Area -->
        <div class="p-3 md:p-4 bg-gray-900 border-t border-gray-800 flex-shrink-0">
            <form id="command-form" class="flex items-center gap-2">
                <span id="prompt-symbol" class="text-green-500 font-bold text-base md:text-lg">&gt;</span>
                <input 
                    type="text" 
                    id="command-input" 
                    class="flex-grow bg-transparent border-none outline-none text-green-400 font-mono placeholder-gray-700 focus:ring-0 text-sm md:text-base"
                    placeholder="Enter command..."
                    autocomplete="off"
                    autofocus
                >
                <button type="submit" class="px-3 py-1 md:px-4 bg-green-900/30 text-green-400 border border-green-800 hover:bg-green-800/50 text-[10px] md:text-xs uppercase tracking-widest transition-colors whitespace-nowrap">
                    SEND
                </button>
            </form>
            <div id="input-hint" class="text-[10px] text-gray-600 mt-1 pl-4 md:pl-6 truncate">Try: 'look', 'move [dir]', 'talk [name]', 'inspect [thing]'</div>
        </div>
    </main>

    <script type="module">
        /**
         * PROTOCOL: VOID v2.0
         * Expanded Narrative & Conversation System
         */

        // --- Sound Engine ---
        const Sound = {
            ctx: null,
            ambientNodes: [],
            ambientGain: null,
            
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.ambientGain = this.ctx.createGain();
                    this.ambientGain.connect(this.ctx.destination);
                    this.ambientGain.gain.value = 0.05; // Master ambient volume
                }
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },

            stopAmbient: function() {
                this.ambientNodes.forEach(n => {
                    try { n.stop(); } catch(e){}
                    try { n.disconnect(); } catch(e){}
                });
                this.ambientNodes = [];
            },

            createNoiseBuffer: function() {
                if (!this.ctx) return;
                const bufferSize = 2 * this.ctx.sampleRate; // 2 seconds
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                return buffer;
            },

            playAmbient: function(type) {
                if (!this.ctx) return;
                this.stopAmbient();
                
                const t = this.ctx.currentTime;
                
                if (type === 'rumble') { // Docking Bay
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = this.createNoiseBuffer();
                    noise.loop = true;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 100;
                    noise.connect(filter);
                    filter.connect(this.ambientGain);
                    noise.start();
                    this.ambientNodes.push(noise);
                }
                else if (type === 'drone') { // Main Hall
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = 60;
                    const osc2 = this.ctx.createOscillator();
                    osc2.type = 'sine';
                    osc2.frequency.value = 62; // Binaural beat effect
                    
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.5;
                    
                    osc.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.ambientGain);
                    
                    osc.start();
                    osc2.start();
                    this.ambientNodes.push(osc, osc2);
                }
                else if (type === 'throb') { // Engineering
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.frequency.value = 50;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 200;
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.type = 'sine';
                    lfo.frequency.value = 2; // 2Hz throb
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 50; // Modulate filter frequency
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(filter.frequency);
                    
                    osc.connect(filter);
                    filter.connect(this.ambientGain);
                    
                    osc.start();
                    lfo.start();
                    this.ambientNodes.push(osc, lfo);
                }
                else if (type === 'wind') { // Cryo Bay
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = this.createNoiseBuffer();
                    noise.loop = true;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 800;
                    
                    noise.connect(filter);
                    filter.connect(this.ambientGain);
                    noise.start();
                    this.ambientNodes.push(noise);
                }
                else if (type === 'electric') { // Server Room
                    const hum = this.ctx.createOscillator();
                    hum.frequency.value = 120;
                    hum.type = 'square';
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400;
                    
                    hum.connect(filter);
                    filter.connect(this.ambientGain);
                    hum.start();
                    this.ambientNodes.push(hum);
                }
            },

            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type; 
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            blip: function() { 
                const f = 800 + Math.random() * 200;
                this.playTone(f, 'square', 0.05, 0.02); 
            },
            success: function() { 
                this.playTone(440, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(880, 'sine', 0.3, 0.1), 100);
            },
            error: function() { 
                this.playTone(150, 'sawtooth', 0.3, 0.1);
                setTimeout(() => this.playTone(100, 'sawtooth', 0.3, 0.1), 150);
            },
            start: function() { this.playTone(220, 'sine', 1, 0.1); },

            setRoomAmbience: function(roomKey) {
                const type = WORLD[roomKey].ambience;
                if (type) this.playAmbient(type);
                else this.stopAmbient();
            }
        };

        // --- DOM Elements ---
        const outputEl = document.getElementById('console-output');
        const inputEl = document.getElementById('command-input');
        const formEl = document.getElementById('command-form');
        const locEl = document.getElementById('status-loc');
        const turnEl = document.getElementById('status-turn');
        const invEl = document.getElementById('inventory-list');
        const notesEl = document.getElementById('doc-notes');
        const evCountEl = document.getElementById('evidence-count');
        const landingPage = document.getElementById('landing-page');
        const gameOverPage = document.getElementById('game-over-page');
        const endRating = document.getElementById('end-rating');
        const endMessage = document.getElementById('end-message');
        const restartBtn = document.getElementById('restart-btn');
        const bootText = document.getElementById('boot-text');
        const startBtn = document.getElementById('start-btn');
        const promptSymbol = document.getElementById('prompt-symbol');
        const inputHint = document.getElementById('input-hint');
        
        // Documentation UI elements
        const docCharsEl = document.getElementById('doc-characters');
        const docEvidenceEl = document.getElementById('doc-evidence');
        const docScenesEl = document.getElementById('doc-scenes');
        const docTabs = document.querySelectorAll('.doc-tab');

        // --- Game State ---
        const DETECTIVE_NAME = "Kael \"Void\" Cross";
        const STATE = {
            mode: 'EXPLORE', // EXPLORE, CONVERSATION, ACCUSE, END
            currentRoom: 'docking_bay',
            turn: 0,
            inventory: [],
            evidence: new Set(),
            notes: [],
            conversationTarget: null,
            documentation: {
                characters: {},
                evidence: {},
                scenes: {},
                timeline: []
            },
            flags: {
                talkedToAria: false,
                inspectedBody: false,
                foundVent: false,
                foundGamblingSlate: false,
                unlockedAria: false,
                chipInstalled: false,
                discussedRookAlibi: false,
                talkedToZara: false,
                talkedToThorne: false,
                talkedToVoss: false,
                talkedToJax: false,
                foundMedicalRecords: false,
                foundSecurityFootage: false,
                foundPoisonTraces: false,
                foundJaxAccessLog: false,
                foundCommandAuth: false,
                foundBlackmailEvidence: false,
                foundSmugglingEvidence: false,
                foundChipSource: false,
                foundTimeDiscrepancy: false,
                foundConspiracyEvidence: false
            }
        };

        // --- Data: World & Narrative ---
        const WORLD = {
            docking_bay: {
                name: "Docking Bay 4",
                desc: "The airlock hisses with residual pressure. Your shuttle has just detached. Station Icarus is silent. To the NORTH is the Main Hall.",
                exits: { north: 'main_hall' },
                items: [],
                npc: null,
                ambience: 'rumble'
            },
            main_hall: {
                name: "Main Hall",
                desc: "The central hub. Emergency lighting casts long shadows. Commander Voss stands near the command console, her expression unreadable. Paths lead NORTH (Server), WEST (Engineering), EAST (Cryo), SOUTH (Docking), NORTHEAST (Medical), NORTHWEST (Security).",
                exits: { north: 'server_room', west: 'engineering', east: 'cryo_bay', south: 'docking_bay', northeast: 'medical_bay', northwest: 'security_office' },
                items: ['command_authorization'],
                npc: 'voss',
                ambience: 'drone'
            },
            engineering: {
                name: "Engineering",
                desc: "The hum of engines is overwhelming. Oil stains the floor. There's a workbench and lockers here. Rook is working at a console, while Jax is nearby. To the EAST is the Main Hall.",
                exits: { east: 'main_hall' },
                items: ['bloody_wrench'], // 'override_chip' is hidden in toolkit
                npc: 'rook',
                ambience: 'throb'
            },
            cryo_bay: {
                name: "Cryo Bay",
                desc: "Frigid air bites your skin. Most pods are empty. A ventilation grate rattles loosely on the wall. To the WEST is the Main Hall.",
                exits: { west: 'main_hall' },
                items: ['tablet'], // 'lab_coat' is hidden in vent
                npc: 'corinne',
                ambience: 'wind'
            },
            server_room: {
                name: "Server Room",
                desc: "Rows of black monolith servers. In the center, the body of Dr. Silas Vane lies slumped over the master console. To the SOUTH is the Main Hall.",
                exits: { south: 'main_hall' },
                items: ['encrypted_drive'],
                npc: null,
                ambience: 'electric'
            },
            medical_bay: {
                name: "Medical Bay",
                desc: "Sterile white walls stained with something dark. Medical equipment beeps erratically. Dr. Zara Chen is reviewing patient logs at a terminal. The air smells of antiseptic and something metallic. To the SOUTHWEST is the Main Hall, WEST is Quarters.",
                exits: { southwest: 'main_hall', west: 'quarters' },
                items: ['medical_logs', 'poison_vial'],
                npc: 'zara',
                ambience: 'wind'
            },
            security_office: {
                name: "Security Office",
                desc: "Banks of monitors flicker with static. Officer Marcus Thorne is hunched over access logs, his face tense. Security footage plays on loop. To the SOUTHEAST is the Main Hall, EAST is Communications Hub.",
                exits: { southeast: 'main_hall', east: 'communications_hub' },
                items: ['security_footage_drive', 'access_card_log', 'smuggling_manifest'],
                npc: 'thorne',
                ambience: 'throb'
            },
            communications_hub: {
                name: "Communications Hub",
                desc: "Antenna arrays stretch into the void. Message logs scroll endlessly. No one is here - the system runs automated. To the WEST is Security Office, NORTH is Research Lab.",
                exits: { west: 'security_office', north: 'research_lab' },
                items: ['message_logs'],
                npc: null,
                ambience: 'drone'
            },
            research_lab: {
                name: "Research Lab (Project Chimera)",
                desc: "Abandoned workstations. Research notes scattered everywhere. This is where Vane and Corinne worked on Project Chimera. The air is thick with the smell of ozone and something else - fear. To the SOUTH is Communications Hub, WEST is Main Hall.",
                exits: { south: 'communications_hub', west: 'main_hall' },
                items: ['project_chimera_files', 'chip_trace_log', 'time_discrepancy_report'],
                npc: null,
                ambience: 'electric'
            },
            quarters: {
                name: "Quarters",
                desc: "Living quarters for the crew. Personal effects scattered about. You can search through individual rooms. Something feels off here. To the EAST is Medical Bay, SOUTHEAST is Main Hall.",
                exits: { east: 'medical_bay', southeast: 'main_hall' },
                items: ['personal_datapad', 'conspiracy_evidence'],
                npc: null,
                ambience: 'rumble'
            }
        };

        const ITEMS = {
            bloody_wrench: {
                name: "Bloody Wrench",
                desc: "Heavy engineering tool. Crusted with blood.",
                evidence: "Murder Weapon"
            },
            tablet: {
                name: "Corinne's Tablet",
                desc: "Unlocks with a standard biometric bypass. It contains angry emails to Vane accusing him of 'stealing her life's work'.",
                evidence: "Corinne's Motive"
            },
            encrypted_drive: {
                name: "Vane's Drive",
                desc: "A bio-locked drive found on the victim. High-level encryption.",
                evidence: null // Needs decrypt
            },
            override_chip: {
                name: "AI Override Chip",
                desc: "A rare hardware key used to bypass AI logic locks. Found in Rook's toolkit.",
                evidence: null
            },
            gambling_slate: {
                name: "Digital Slate",
                desc: "Found in Rook's locker. It shows massive debts to an off-world syndicate.",
                evidence: "Rook's Debt"
            },
            lab_coat: {
                name: "Torn Lab Coat",
                desc: "Found stuffed in the vent. It's stained with blood and smells of server coolant.",
                evidence: "Bloody Coat"
            },
            medical_logs: {
                name: "Medical Records",
                desc: "Dr. Chen's patient logs. Shows Vane was treated for weakness and dizziness hours before death. Toxicology report indicates traces of a sedative.",
                evidence: "Medical Records"
            },
            security_footage_drive: {
                name: "Security Footage Drive",
                desc: "Contains surveillance footage from the night of the murder. Some segments are missing or corrupted.",
                evidence: "Security Footage"
            },
            message_logs: {
                name: "Message Logs",
                desc: "Intercepted communications. Shows suspicious off-station messages around the time of death.",
                evidence: "Off-Station Communications"
            },
            project_chimera_files: {
                name: "Project Chimera Files",
                desc: "Detailed research notes. Shows Vane's name on work clearly done by Corinne. Dates prove theft.",
                evidence: "Research Theft Proof"
            },
            personal_datapad: {
                name: "Personal Datapad",
                desc: "Found in quarters. Contains blackmail messages from Vane to Jax about illegal tech modifications.",
                evidence: "Blackmail Evidence"
            },
            poison_vial: {
                name: "Sedative Vial",
                desc: "Found in Medical Bay. Empty. Matches the sedative found in Vane's system.",
                evidence: "Poison Traces"
            },
            access_card_log: {
                name: "Access Card Log",
                desc: "Shows Jax's access card was used to enter Server Room at 01:55, just before the murder.",
                evidence: "Jax's Access Log"
            },
            command_authorization: {
                name: "Command Authorization",
                desc: "Voss authorized something suspicious - a data purge right after Vane's death.",
                evidence: "Command Authorization"
            },
            smuggling_manifest: {
                name: "Smuggling Manifest",
                desc: "Found in Security Office. Shows Thorne was involved in illegal cargo operations.",
                evidence: "Smuggling Operation"
            },
            chip_trace_log: {
                name: "Chip Trace Log",
                desc: "Technical logs showing the override chip was issued to Jax, not Rook.",
                evidence: "Override Chip Source"
            },
            time_discrepancy_report: {
                name: "Time Discrepancy Report",
                desc: "Medical records show time of death at 02:10, but security logs show activity until 02:15.",
                evidence: "Time of Death Discrepancy"
            },
            conspiracy_evidence: {
                name: "Conspiracy Evidence",
                desc: "Multiple encrypted messages between Voss, Thorne, and an unknown party about covering up Project Chimera.",
                evidence: "Conspiracy Evidence"
            }
        };

        // --- Conversation Trees ---
        const CONVERSATIONS = {
            aria: {
                start: `A.R.I.A: 'Identity confirmed. ${DETECTIVE_NAME}, my core logic is... compromised. Error 404: Memory fragment missing.'`,
                topics: [
                    {
                        id: 'status',
                        text: "Report station status.",
                        response: "All systems critical. Life support at 40%. Dr. Vane attempted a manual override before... termination.",
                        note: "Vane tried to override the system before dying."
                    },
                    {
                        id: 'witness',
                        text: "Did you see the killer?",
                        response: "Visual sensors in Server Room were... deleted. However, audio logs remain. I cannot access them without the Override Chip.",
                        note: "A.R.I.A needs an Override Chip to access audio logs."
                    },
                    {
                        id: 'alibi',
                        text: "Verify Rook's alibi (Scrubbers).",
                        // Only show if Rook told you
                        reqNote: "Rook claims he was fixing scrubbers.",
                        response: "Accessing Maintenance Logs... Confirmed. Rook was sealing a CO2 leak in the Lower Deck at the estimated time of death. He could not be the killer.",
                        evidence: "Rook's Alibi",
                        note: "Aria confirmed Rook was working during the murder."
                    },
                    {
                        id: 'chip',
                        text: "[Use Override Chip] Install chip and unlock memory.",
                        reqItem: 'override_chip',
                        response: "Accessing... Block removed. Playing Audio Log: 'Vane: You? But why? ... No, put that down! Argh!' ... I detect two voices. One is Vane. The other matches biometric profile: FEMALE.",
                        evidence: "Audio Log (Female Voice)",
                        note: "The killer is female. This clears Rook of the murder."
                    }
                ]
            },
            rook: {
                start: "Rook slams a drawer shut. 'What? I'm busy keeping this rust bucket from exploding.'",
                topics: [
                    {
                        id: 'alibi',
                        text: "Where were you at 0200h?",
                        response: "I was here! Fixing the CO2 scrubbers. Ask the tin can (A.R.I.A), she tracks maintenance cycles.",
                        note: "Rook claims he was fixing scrubbers."
                    },
                    {
                        id: 'tools',
                        text: "[Show Wrench] Is this yours?",
                        reqEvidence: 'Murder Weapon',
                        response: "Yeah, that's my serial number. But I lost my kit two days ago! Someone swiped it while I was sleeping.",
                        note: "Rook claims his tools were stolen."
                    },
                    {
                        id: 'debt',
                        text: "[Show Slate] You have a lot of debt, Rook.",
                        reqEvidence: "Rook's Debt",
                        response: "Rook pales. 'Okay, look. I owe credits. Bad people. But I didn't kill Vane! I was hacking the mess hall credits to pay them off. That's why I was awake!'",
                        note: "Rook admits to hacking mess hall, not killing."
                    }
                ]
            },
            corinne: {
                start: "Dr. Corinne doesn't look up from her datapad. 'Make it quick. My samples are degrading.'",
                topics: [
                    {
                        id: 'vane',
                        text: "Relationship with Dr. Vane?",
                        response: "Silas was a thief. He took my research on Project Chimera and put his name on it. I hated him, yes. But murder is inefficient.",
                        note: "Corinne hated Vane for stealing credit."
                    },
                    {
                        id: 'coat',
                        text: "[Show Lab Coat] Found this in the vent.",
                        reqEvidence: 'Bloody Coat',
                        response: "She freezes. 'I... I panicked. I went to talk to him. He was already dead. I saw the blood, slipped... I didn't want to be blamed.'",
                        note: "Corinne admits to being at the scene."
                    },
                    {
                        id: 'audio',
                        text: "[Show Audio Log] The AI recorded a female voice.",
                        reqEvidence: 'Audio Log (Female Voice)',
                        response: "Corinne sighs, trembling. 'He was going to sell the AI logic to the military. He was going to wipe A.R.I.A! I just wanted to stop him destroying my creation! He attacked me... it was self defense!'",
                        evidence: "Corinne's Confession",
                        note: "Corinne confesses to killing Vane in self-defense (or so she claims)."
                    }
                ]
            },
            zara: {
                start: "Dr. Zara Chen looks up from her terminal, exhaustion in her eyes. 'Detective Cross. I've been expecting you. Vane was my patient.'",
                topics: [
                    {
                        id: 'vane_condition',
                        text: "What was Vane's condition?",
                        response: "He came to me hours before... before it happened. Complained of dizziness, weakness. I ran tests - found traces of a sedative in his system. Someone had been poisoning him slowly.",
                        evidence: "Medical Records",
                        note: "Vane was weakened before the attack - premeditation."
                    },
                    {
                        id: 'who_poisoned',
                        text: "Who could have poisoned him?",
                        response: "Anyone with access to medical supplies. But the sedative... it's restricted. Only medical staff and... security have access. Thorne has been acting strange lately.",
                        note: "Thorne might have had access to the sedative."
                    },
                    {
                        id: 'timeline',
                        text: "What's the medical timeline?",
                        response: "Vane came in at 01:30. I treated him, ran tests. He left around 01:45. Medical records show time of death around 02:10, but... that doesn't match what security is saying.",
                        evidence: "Time of Death Discrepancy",
                        note: "Medical and security timelines don't match."
                    }
                ]
            },
            thorne: {
                start: "Officer Marcus Thorne doesn't look up from his monitors. 'Detective. I'm busy reviewing security footage. What do you want?'",
                topics: [
                    {
                        id: 'footage',
                        text: "What does the security footage show?",
                        response: "Most of it's corrupted. Missing segments around 02:00 to 02:15. What I can see shows... a struggle. But the killer's face is obscured.",
                        evidence: "Security Footage",
                        note: "Security footage is partially corrupted, missing key moments."
                    },
                    {
                        id: 'access_logs',
                        text: "Show me the access logs.",
                        response: "Multiple people accessed the Server Room that night. Rook's card, Jax's card... even Voss's authorization. But biometrics don't match the card users.",
                        note: "Access cards were used by different people than their owners."
                    },
                    {
                        id: 'smuggling',
                        text: "[Show Smuggling Manifest] Explain this.",
                        reqEvidence: 'Smuggling Operation',
                        response: "Thorne's face pales. 'That's... classified. Vane found out. He was going to expose me. But I didn't kill him! I was... I was trying to cover it up, yes, but murder? No.'",
                        evidence: "Smuggling Operation",
                        note: "Thorne admits to smuggling but denies murder."
                    },
                    {
                        id: 'gaps',
                        text: "Why are there gaps in the footage?",
                        response: "Someone with high-level access deleted those segments. Only Voss or... someone with command codes could do that. I've been trying to recover them.",
                        note: "Someone with high access deleted security footage."
                    }
                ]
            },
            voss: {
                start: "Commander Helena Voss stands rigid, her uniform immaculate. 'Detective Cross. I trust you're making progress. The station's orbit is decaying. We need answers.'",
                topics: [
                    {
                        id: 'project_chimera',
                        text: "What do you know about Project Chimera?",
                        response: "Classified research. Vane and Corinne were working on it. Corporate wants it kept quiet. That's all I can say.",
                        note: "Voss knows about Project Chimera but won't elaborate."
                    },
                    {
                        id: 'authorization',
                        text: "[Show Command Authorization] Why did you authorize a data purge?",
                        reqEvidence: 'Command Authorization',
                        response: "Standard protocol after a security breach. I was following procedure. Nothing suspicious about it.",
                        evidence: "Command Authorization",
                        note: "Voss authorized data purge right after murder - suspicious timing."
                    },
                    {
                        id: 'crew',
                        text: "What do you know about the crew?",
                        response: "Rook has debts. Corinne and Vane had conflicts. Thorne... has been acting off. Jax is new, transferred in recently. But I don't believe any of them are killers.",
                        note: "Voss knows about crew issues but defends them."
                    },
                    {
                        id: 'conspiracy',
                        text: "[Show Conspiracy Evidence] Explain these messages.",
                        reqEvidence: 'Conspiracy Evidence',
                        response: "Voss's composure breaks. 'You... you found them. Fine. Corporate wanted Project Chimera covered up. Vane was going to expose it. We were trying to... contain the situation. But I didn't order his death!'",
                        evidence: "Conspiracy Evidence",
                        note: "Voss admits to conspiracy but denies ordering the murder."
                    }
                ]
            },
            jax: {
                start: "Jax looks up from the console, tension in his shoulders. 'Detective. Rook's been telling you things, hasn't he? Don't believe everything you hear.'",
                topics: [
                    {
                        id: 'rook',
                        text: "What's your relationship with Rook?",
                        response: "We work together. That's it. He thinks I'm after his job. Maybe I am. But that doesn't make me a killer.",
                        note: "Jax and Rook have a rivalry."
                    },
                    {
                        id: 'access',
                        text: "[Show Access Log] Your card accessed Server Room before the murder.",
                        reqEvidence: "Jax's Access Log",
                        response: "Jax freezes. 'That's... I was doing maintenance. Routine check. I didn't see Vane. I swear!'",
                        evidence: "Jax's Access Log",
                        note: "Jax was in Server Room just before murder."
                    },
                    {
                        id: 'blackmail',
                        text: "[Show Blackmail Evidence] Vane was blackmailing you.",
                        reqEvidence: 'Blackmail Evidence',
                        response: "Jax's face darkens. 'Yeah. He found out about some... modifications I made. Illegal tech tweaks. He was going to turn me in unless I paid him. But killing him? That's not how I solve problems.'",
                        evidence: "Blackmail Evidence",
                        note: "Jax admits to being blackmailed but denies murder."
                    },
                    {
                        id: 'chip',
                        text: "[Show Chip Trace] The override chip was issued to you.",
                        reqEvidence: 'Override Chip Source',
                        response: "Jax looks shocked. 'I... I lost it. Weeks ago. Someone must have stolen it. I reported it missing! Check the logs!'",
                        evidence: "Override Chip Source",
                        note: "Jax claims the chip was stolen from him."
                    }
                ]
            }
        };

        // --- System Functions ---

        function updateUI() {
            locEl.innerText = WORLD[STATE.currentRoom].name;
            turnEl.innerText = STATE.turn;
            // Calculate max evidence (all possible evidence pieces)
            const maxEvidence = 20; // Updated for expanded evidence system
            evCountEl.innerText = `${STATE.evidence.size}/${maxEvidence}`;
            
            // Map
            document.querySelectorAll('.map-cell').forEach(el => el.classList.remove('active'));
            const mapId = `map-${STATE.currentRoom}`;
            const activeCell = document.getElementById(mapId);
            if (activeCell) activeCell.classList.add('active');

            // Inventory
            invEl.innerHTML = '';
            if (STATE.inventory.length === 0) {
                invEl.innerHTML = '<li class="italic text-gray-700 opacity-50">Empty...</li>';
            } else {
                STATE.inventory.forEach(itemKey => {
                    const li = document.createElement('li');
                    li.innerText = `> ${ITEMS[itemKey].name}`;
                    li.className = "text-cyan-500 glow-text";
                    invEl.appendChild(li);
                });
            }

            // Notes (in documentation system)
            notesEl.innerHTML = '';
            if (STATE.notes.length === 0) {
                notesEl.innerHTML = '<div class="italic opacity-30">No data recorded.</div>';
            } else {
                STATE.notes.forEach(note => {
                    const div = document.createElement('div');
                    div.className = 'text-[9px] mb-1';
                    div.innerText = ` ${note}`;
                    notesEl.appendChild(div);
                });
            }
            
            // Update documentation
            updateDocumentation();
        }

        // --- Documentation Functions ---
        
        function documentCharacter(npcKey) {
            if (STATE.documentation.characters[npcKey]) return; // Already documented
            
            const npcData = CONVERSATIONS[npcKey];
            if (!npcData) return;
            
            const room = Object.values(WORLD).find(r => r.npc === npcKey);
            const location = room ? room.name : 'Unknown';
            
            STATE.documentation.characters[npcKey] = {
                name: npcKey.charAt(0).toUpperCase() + npcKey.slice(1),
                role: getCharacterRole(npcKey),
                location: location,
                status: getCharacterStatus(npcKey),
                description: getCharacterDescription(npcKey),
                notes: [],
                keyInfo: []
            };
            
            updateDocumentation();
        }
        
        function getCharacterRole(npcKey) {
            const roles = {
                'aria': 'AI Mainframe',
                'rook': 'Station Engineer',
                'corinne': 'Research Scientist',
                'zara': 'Medical Officer',
                'thorne': 'Security Chief',
                'voss': 'Station Commander',
                'jax': 'Tech Specialist'
            };
            return roles[npcKey] || 'Unknown';
        }
        
        function getCharacterStatus(npcKey) {
            const statuses = {
                'aria': 'Witness/Neutral',
                'rook': 'Suspect (Cleared)',
                'corinne': 'Primary Suspect',
                'zara': 'Witness/Neutral',
                'thorne': 'Suspect',
                'voss': 'Suspect/Authority',
                'jax': 'Suspect'
            };
            return statuses[npcKey] || 'Unknown';
        }
        
        function getCharacterDescription(npcKey) {
            const descs = {
                'aria': 'Glitched AI with missing memory fragments. Helpful but cryptic.',
                'rook': 'Station engineer, gruff personality. Has gambling debts but has alibi.',
                'corinne': 'Research scientist, worked on Project Chimera. Motive: Vane stole her research.',
                'zara': 'Medical officer, treated Vane. Professional, concerned about patient care.',
                'thorne': 'Security chief, suspicious behavior. Might be covering something up.',
                'voss': 'Station authority, knows more than she tells. Might be protecting secrets.',
                'jax': 'Tech specialist, rival to Rook. Access to override chips and tools.'
            };
            return descs[npcKey] || 'No description available.';
        }
        
        function documentEvidence(evidenceName, location, type = 'physical') {
            if (STATE.documentation.evidence[evidenceName]) return;
            
            // Find item description if available
            let description = '';
            for (const [itemKey, item] of Object.entries(ITEMS)) {
                if (item.evidence === evidenceName) {
                    description = item.desc;
                    break;
                }
            }
            
            STATE.documentation.evidence[evidenceName] = {
                name: evidenceName,
                type: type,
                location: location,
                description: description,
                connections: []
            };
            
            updateDocumentation();
        }
        
        function documentScene(roomKey, event) {
            if (!STATE.documentation.scenes[roomKey]) {
                const room = WORLD[roomKey];
                STATE.documentation.scenes[roomKey] = {
                    name: room.name,
                    description: room.desc,
                    items: [],
                    npcs: room.npc ? [room.npc] : [],
                    keyEvents: []
                };
            }
            
            if (event) {
                STATE.documentation.scenes[roomKey].keyEvents.push(event);
            }
            
            updateDocumentation();
        }
        
        function updateCharacterInfo(npcKey, info) {
            if (!STATE.documentation.characters[npcKey]) return;
            if (!STATE.documentation.characters[npcKey].notes.includes(info)) {
                STATE.documentation.characters[npcKey].notes.push(info);
                updateDocumentation();
            }
        }
        
        function updateDocumentation() {
            // Update Characters tab
            docCharsEl.innerHTML = '';
            const chars = Object.values(STATE.documentation.characters);
            if (chars.length === 0) {
                docCharsEl.innerHTML = '<div class="italic opacity-30">No characters documented yet.</div>';
            } else {
                chars.forEach(char => {
                    const div = document.createElement('div');
                    div.className = 'mb-2 pb-2 border-b border-gray-800';
                    div.innerHTML = `
                        <div class="font-bold text-amber-400">${char.name}</div>
                        <div class="text-[9px] text-gray-500">${char.role} | ${char.location}</div>
                        <div class="text-[9px] text-cyan-400">Status: ${char.status}</div>
                        <div class="text-[9px] mt-1">${char.description}</div>
                        ${char.notes.length > 0 ? '<div class="text-[9px] mt-1 text-gray-500">' + char.notes.join('; ') + '</div>' : ''}
                    `;
                    docCharsEl.appendChild(div);
                });
            }
            
            // Update Evidence tab
            docEvidenceEl.innerHTML = '';
            const evidence = Object.values(STATE.documentation.evidence);
            if (evidence.length === 0) {
                docEvidenceEl.innerHTML = '<div class="italic opacity-30">No evidence documented yet.</div>';
            } else {
                evidence.forEach(ev => {
                    const div = document.createElement('div');
                    div.className = 'mb-2 pb-2 border-b border-gray-800';
                    const typeColor = ev.type === 'physical' ? 'text-red-400' : ev.type === 'digital' ? 'text-cyan-400' : 'text-yellow-400';
                    div.innerHTML = `
                        <div class="font-bold ${typeColor}">[${ev.type.toUpperCase()}] ${ev.name}</div>
                        <div class="text-[9px] text-gray-500">Found: ${ev.location}</div>
                        ${ev.description ? '<div class="text-[9px] mt-1">' + ev.description + '</div>' : ''}
                    `;
                    docEvidenceEl.appendChild(div);
                });
            }
            
            // Update Scenes tab
            docScenesEl.innerHTML = '';
            const scenes = Object.values(STATE.documentation.scenes);
            if (scenes.length === 0) {
                docScenesEl.innerHTML = '<div class="italic opacity-30">No scenes documented yet.</div>';
            } else {
                scenes.forEach(scene => {
                    const div = document.createElement('div');
                    div.className = 'mb-2 pb-2 border-b border-gray-800';
                    div.innerHTML = `
                        <div class="font-bold text-green-400">${scene.name}</div>
                        <div class="text-[9px] mt-1">${scene.description}</div>
                        ${scene.items.length > 0 ? '<div class="text-[9px] text-cyan-400 mt-1">Items: ' + scene.items.join(', ') + '</div>' : ''}
                        ${scene.npcs.length > 0 ? '<div class="text-[9px] text-amber-400 mt-1">NPCs: ' + scene.npcs.join(', ') + '</div>' : ''}
                    `;
                    docScenesEl.appendChild(div);
                });
            }
        }
        
        // Tab switching
        docTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                docTabs.forEach(t => {
                    t.classList.remove('active', 'bg-gray-800', 'text-amber-500');
                    t.classList.add('text-gray-600');
                });
                tab.classList.add('active', 'bg-gray-800', 'text-amber-500');
                tab.classList.remove('text-gray-600');
                
                document.querySelectorAll('.doc-content').forEach(content => {
                    content.classList.add('hidden');
                });
                document.getElementById(`doc-${targetTab}`).classList.remove('hidden');
            });
        });

        function addNote(text) {
            if (!STATE.notes.includes(text)) {
                STATE.notes.push(text);
                updateUI();
                printInstant(`[NOTE ADDED: ${text}]`, 'text-[10px] text-amber-500');
            }
        }

        function addEvidence(evName) {
            if (evName && !STATE.evidence.has(evName)) {
                STATE.evidence.add(evName);
                Sound.success();
                printLine(`EVIDENCE LOGGED: [${evName}]`, 'txt-success');
                
                // Auto-document evidence
                const room = WORLD[STATE.currentRoom];
                documentEvidence(evName, room.name, 'physical');
                
                updateUI();
            }
        }

        // --- Output & Animations ---

        let isTyping = false;
        
        async function printLine(text, className = '') {
            return new Promise(resolve => {
                const p = document.createElement('p');
                if (className) p.className = className;
                outputEl.appendChild(p);
                
                if (className.includes('txt-error')) Sound.error();

                isTyping = true;
                let i = 0;
                // Faster typing for better UX
                const speed = 10; 
                
                function type() {
                    if (i < text.length) {
                        p.textContent += text.charAt(i);
                        if (i % 3 === 0) Sound.blip(); 
                        i++;
                        outputEl.scrollTop = outputEl.scrollHeight;
                        setTimeout(type, speed);
                    } else {
                        isTyping = false;
                        resolve();
                    }
                }
                type();
            });
        }

        function printInstant(text, className = '') {
            const p = document.createElement('p');
            if (className) p.className = className;
            p.textContent = text;
            outputEl.appendChild(p);
            outputEl.scrollTop = outputEl.scrollHeight;
        }

        function printClickableOption(text, callback) {
            const p = document.createElement('p');
            p.className = 'txt-choice ml-4 hover:text-green-400 cursor-pointer transition-colors'; 
            p.innerText = text;
            p.onclick = callback;
            outputEl.appendChild(p);
            outputEl.scrollTop = outputEl.scrollHeight;
        }

        function showGameOver(rank, msg, colorClass) {
            endRating.innerText = `RANK: ${rank}`;
            endRating.className = `text-6xl md:text-9xl font-bold mb-8 glow-text ${colorClass}`;
            endMessage.innerText = msg;
            gameOverPage.classList.remove('hidden');
            // Trigger reflow for fade in
            void gameOverPage.offsetWidth; 
            gameOverPage.classList.add('visible');
            Sound.stopAmbient();
        }

        // --- Core Logic ---

        async function look() {
            const room = WORLD[STATE.currentRoom];
            await printLine(`LOCATION: ${room.name}`, 'text-white font-bold underline mt-4');
            await printLine(room.desc, 'text-gray-300');
            
            // Document scene on first look
            documentScene(STATE.currentRoom);
            
            // Show visible items
            if (room.items.length > 0) {
                const names = room.items.map(k => ITEMS[k].name).join(', ');
                await printLine(`VISIBLE: ${names}`, 'txt-item');
            }
            if (room.npc) {
                await printLine(`DETECTED: ${room.npc.toUpperCase()}`, 'txt-warn');
                // Auto-document character if present
                documentCharacter(room.npc);
            }
        }

        async function inspect(target) {
            const room = WORLD[STATE.currentRoom];

            // Normalize target synonyms
            let actualTarget = target;
            if (['grate', 'ventilation'].includes(target)) actualTarget = 'vent';
            if (['workbench', 'tools', 'table'].includes(target)) actualTarget = 'toolkit';
            if (['lockers', 'cabinet'].includes(target)) actualTarget = 'locker';
            if (['corpse', 'vane', 'man', 'victim'].includes(target)) actualTarget = 'body';

            // 1. Inspect Room/Scenery (Hidden Items Logic)
            if (actualTarget === 'room' || actualTarget === 'area' || actualTarget === 'vent' || actualTarget === 'locker' || actualTarget === 'toolkit' || actualTarget === 'body') {
                
                // CRYO VENT
                if (STATE.currentRoom === 'cryo_bay' && actualTarget === 'vent') {
                    if (!STATE.flags.foundVent) {
                        STATE.flags.foundVent = true;
                        room.items.push('lab_coat');
                        await printLine("You pry open the loose grate. Something white is stuffed inside.", 'txt-sys');
                        await printLine("REVEALED: Torn Lab Coat.", 'txt-item');
                        addNote("Found a bloody lab coat hidden in Cryo Bay vents.");
                    } else if (room.items.includes('lab_coat')) {
                        await printLine("The vent is open. The lab coat is still there.", 'txt-sys');
                    } else {
                        await printLine("The vent is empty, save for dust.", 'txt-sys');
                    }
                    return;
                }
                
                // ENG TOOLKIT
                if (STATE.currentRoom === 'engineering' && actualTarget === 'toolkit') {
                     if (!STATE.flags.chipInstalled) {
                        // Check if chip is there
                        if (!STATE.inventory.includes('override_chip') && !room.items.includes('override_chip')) {
                            room.items.push('override_chip');
                            await printLine("You rummage through the toolkit. It looks like it was hastily hidden under the bench.", 'txt-sys');
                            await printLine("REVEALED: AI Override Chip.", 'txt-item');
                        } else if (room.items.includes('override_chip')) {
                            await printLine("Rook's toolkit is open. The chip is visible.", 'txt-sys');
                        } else {
                            await printLine("Just some rusty wrenches and fusion tape.", 'txt-sys');
                        }
                    } else {
                        await printLine("Just some rusty wrenches and fusion tape.", 'txt-sys');
                    }
                    return;
                }
                
                // ENG LOCKER
                if (STATE.currentRoom === 'engineering' && actualTarget === 'locker') {
                    if (!STATE.flags.foundGamblingSlate) {
                        STATE.flags.foundGamblingSlate = true;
                        room.items.push('gambling_slate');
                        await printLine("You force open Rook's locker. A digital slate falls out.", 'txt-sys');
                        await printLine("REVEALED: Digital Slate.", 'txt-item');
                    } else if (room.items.includes('gambling_slate')) {
                        await printLine("The locker is open. The slate is on the floor.", 'txt-sys');
                    } else {
                        await printLine("Rook's locker contains dirty uniforms and empty ration packs.", 'txt-sys');
                    }
                    return;
                }
                
                // SERVER BODY
                if (actualTarget === 'body' && STATE.currentRoom === 'server_room') {
                    if (!STATE.flags.inspectedBody) {
                        STATE.flags.inspectedBody = true;
                        await printLine("Dr. Vane died from blunt force trauma. He is clutching a drive.", 'txt-warn');
                        addNote("Vane died from blunt force trauma.");
                    } else {
                        await printLine("You've examined the body already. Vane is gone.", 'txt-sys');
                    }
                    return;
                }
            }

            // 2. Inspect Items (Inventory or Room)
            let itemKey = STATE.inventory.find(k => ITEMS[k].name.toLowerCase().includes(actualTarget) || k.includes(actualTarget));
            if (!itemKey) itemKey = room.items.find(k => ITEMS[k].name.toLowerCase().includes(actualTarget) || k.includes(actualTarget));

            if (itemKey) {
                const item = ITEMS[itemKey];
                await printLine(`ANALYZING: ${item.name}`, 'txt-sys');
                await printLine(item.desc, 'txt-item');
                
                // Update scene documentation with found item
                if (!STATE.documentation.scenes[STATE.currentRoom]) {
                    documentScene(STATE.currentRoom);
                }
                if (!STATE.documentation.scenes[STATE.currentRoom].items.includes(item.name)) {
                    STATE.documentation.scenes[STATE.currentRoom].items.push(item.name);
                }
                
                // Special interaction for Encrypted Drive
                if (itemKey === 'encrypted_drive') {
                    if (STATE.flags.talkedToAria) {
                         await printLine("SYSTEM: Decryption Key verified (Source: A.R.I.A). Accessing...", 'txt-success');
                         await printLine("DATA RECOVERED: Access Logs show Rook's ID card was used to enter the Server Room at 02:00, but biometric weight sensors suggest a user much lighter than Rook.", 'txt-item');
                         addEvidence("Access Logs");
                         documentEvidence("Access Logs", WORLD[STATE.currentRoom].name, 'digital');
                         addNote("Drive decrypted: Rook's card used, but user was lighter than him.");
                    } else {
                         await printLine("ERROR: Decryption Key required. Consult Station AI.", 'txt-error');
                         await printLine("HINT: Talk to A.R.I.A. in the Main Hall to get the decryption key.", 'txt-sys');
                    }
                } else if (item.evidence) {
                    addEvidence(item.evidence);
                    documentEvidence(item.evidence, WORLD[STATE.currentRoom].name, 
                        itemKey.includes('log') || itemKey.includes('drive') || itemKey.includes('datapad') || itemKey.includes('footage') || itemKey.includes('manifest') || itemKey.includes('authorization') || itemKey.includes('evidence') || itemKey.includes('report') ? 'digital' : 'physical');
                }
            } else {
                await printLine("TARGET NOT FOUND.", 'txt-error');
            }
        }

        // --- Conversation System ---

        async function startConversation(npcKey) {
            STATE.mode = 'CONVERSATION';
            STATE.conversationTarget = npcKey;

            // Auto-document character on first meeting
            documentCharacter(npcKey);
            
            // Document scene
            documentScene(STATE.currentRoom, `Talked to ${npcKey}`);

            // Set specific flags based on conversation initiation
            if (npcKey === 'aria') {
                if (!STATE.flags.talkedToAria) {
                    STATE.flags.talkedToAria = true;
                    addNote("Established link with A.R.I.A. Shared protocols exchanged.");
                }
            } else if (npcKey === 'zara') {
                if (!STATE.flags.talkedToZara) {
                    STATE.flags.talkedToZara = true;
                }
            } else if (npcKey === 'thorne') {
                if (!STATE.flags.talkedToThorne) {
                    STATE.flags.talkedToThorne = true;
                }
            } else if (npcKey === 'voss') {
                if (!STATE.flags.talkedToVoss) {
                    STATE.flags.talkedToVoss = true;
                }
            } else if (npcKey === 'jax') {
                if (!STATE.flags.talkedToJax) {
                    STATE.flags.talkedToJax = true;
                }
            }
            
            // Clear input styling
            inputHint.innerText = "Type the number of your choice or Click an option. Type '0' to exit.";
            promptSymbol.className = "text-amber-500 font-bold text-lg";
            
            const data = CONVERSATIONS[npcKey];
            printInstant("------------------------------------------------", 'txt-sys');
            await printLine(`COMM LINK ESTABLISHED: ${npcKey.toUpperCase()}`, 'txt-warn');
            await printLine(data.start, 'text-white italic mb-2');
            
            showConversationOptions();
        }

        async function showConversationOptions() {
            if (!STATE.conversationTarget) return; // Safety check for race condition
            const data = CONVERSATIONS[STATE.conversationTarget];
            if (!data) return; // Safety check

            printInstant("SELECT RESPONSE:", 'txt-sys');
            
            let optionIndex = 1;
            const validOptions = [];

            data.topics.forEach(topic => {
                // Check requirements
                let show = true;
                if (topic.reqEvidence && !STATE.evidence.has(topic.reqEvidence)) show = false;
                if (topic.reqItem && !STATE.inventory.includes(topic.reqItem)) show = false;
                // Note Requirement check
                if (topic.reqNote) {
                    const hasNote = STATE.notes.some(n => n.includes(topic.reqNote) || n === topic.reqNote);
                    if (!hasNote) show = false;
                }
                
                if (show) {
                    const currentIdx = optionIndex;
                    printClickableOption(`[${currentIdx}] ${topic.text}`, () => {
                        if (isTyping) return;
                        printInstant(`> ${currentIdx}`, 'text-gray-600');
                        handleConversationInput(currentIdx.toString());
                    });
                    
                    topic._index = optionIndex; // Store temporary index
                    validOptions.push(topic);
                    optionIndex++;
                }
            });
            
            printClickableOption(`[0] End Conversation`, () => {
                if (isTyping) return;
                printInstant(`> 0`, 'text-gray-600');
                handleConversationInput('0');
            });
            
            STATE.currentOptions = validOptions;
        }

        async function handleConversationInput(input) {
            const choice = parseInt(input);
            
            if (isNaN(choice)) {
                await printLine("INVALID SELECTION.", 'txt-error');
                return;
            }

            if (choice === 0) {
                // Exit conversation
                STATE.mode = 'EXPLORE';
                STATE.conversationTarget = null;
                promptSymbol.className = "text-green-500 font-bold text-lg";
                inputHint.innerText = "Try: 'look', 'move [dir]', 'talk [name]', 'inspect [thing]'";
                await printLine("LINK TERMINATED.", 'txt-sys');
                printInstant("------------------------------------------------", 'txt-sys');
                return;
            }

            const selectedTopic = STATE.currentOptions.find(t => t._index === choice);
            
            if (selectedTopic) {
                // Display user question
                printInstant(`You: "${selectedTopic.text}"`, 'text-gray-500 mt-2');
                
                // Display response
                await printLine(`> ${selectedTopic.response}`, 'text-amber-300 mb-2');
                
                // Logic side effects
                if (selectedTopic.note) {
                    addNote(selectedTopic.note);
                    if (STATE.conversationTarget) {
                        updateCharacterInfo(STATE.conversationTarget, selectedTopic.note);
                    }
                }
                if (selectedTopic.evidence) {
                    addEvidence(selectedTopic.evidence);
                    documentEvidence(selectedTopic.evidence, WORLD[STATE.currentRoom].name, 'testimonial');
                }
                if (selectedTopic.reqItem === 'override_chip' && STATE.conversationTarget === 'aria') {
                    // Consume chip logic
                    STATE.flags.chipInstalled = true;
                }

                // Show options again
                await new Promise(r => setTimeout(r, 500));
                
                // Double check state before re-rendering options to prevent race conditions
                if (STATE.mode === 'CONVERSATION' && STATE.conversationTarget) {
                    showConversationOptions();
                }
            } else {
                await printLine("OPTION UNAVAILABLE.", 'txt-error');
            }
        }

        // --- Main Command Parser ---

        async function parseCommand(raw) {
            const inputRaw = raw.trim().toLowerCase();
            if (!inputRaw) return;
            
            Sound.init(); // Ensure audio context

            // 1. Conversation Mode Handling
            if (STATE.mode === 'CONVERSATION') {
                printInstant(`> ${raw}`, 'text-gray-600');
                await handleConversationInput(inputRaw);
                return;
            }

            // 2. Accusation Mode Handling
            if (STATE.mode === 'ACCUSE') {
                printInstant(`> ${raw}`, 'text-gray-600');
                await handleAccusation(inputRaw);
                return;
            }

            // 3. Exploration Mode Handling
            printInstant(`> ${raw}`, 'txt-sys opacity-50');

            // Tokenizer with filler word removal
            const tokens = inputRaw.split(' ').filter(t => t.trim() !== '');
            const verb = tokens[0];
            
            // List of ignored filler words
            const fillers = ['to', 'the', 'at', 'with', 'from', 'a', 'an', 'in', 'on'];
            
            // Reconstruct noun without fillers
            const noun = tokens.slice(1).filter(word => !fillers.includes(word)).join(' ');

            if (verb === 'help') {
                await printLine("AVAILABLE COMMANDS:", 'txt-nav mb-2');
                const helps = [
                    { cmd: "LOOK / L", desc: "Examine current location." },
                    { cmd: "MOVE [DIR]", desc: "Travel (N/S/E/W/NE/NW/SE/SW or room name)." },
                    { cmd: "INSPECT [OBJ]", desc: "Examine an item or environment detail." },
                    { cmd: "TAKE [ITEM]", desc: "Pick up an item." },
                    { cmd: "TALK [NAME]", desc: "Converse with a character." },
                    { cmd: "INV", desc: "List carried items." },
                    { cmd: "ACCUSE", desc: "Identify the killer (Ends Game)." }
                ];
                for (let h of helps) {
                    printInstant(` ${h.cmd.padEnd(12)} : ${h.desc}`, 'text-gray-400 text-xs md:text-sm ml-2');
                }
                return;
            }


            if (verb === 'look' || verb === 'l') {
                await look();
                return;
            }

            if (verb === 'move' || verb === 'go' || verb === 'walk') {
                const room = WORLD[STATE.currentRoom];
                
                // Normalize direction input
                const dirMap = {
                    'n': 'north', 's': 'south', 'e': 'east', 'w': 'west',
                    'ne': 'northeast', 'nw': 'northwest', 'se': 'southeast', 'sw': 'southwest',
                    'north': 'north', 'south': 'south', 'east': 'east', 'west': 'west',
                    'northeast': 'northeast', 'northwest': 'northwest',
                    'southeast': 'southeast', 'southwest': 'southwest'
                };
                
                const normalizedDir = dirMap[noun.toLowerCase()] || noun.toLowerCase();
                
                // Check for cardinal/diagonal direction
                let newRoomKey = room.exits[normalizedDir] || room.exits[noun] || room.exits[noun.charAt(0)];
                
                // If not a direction, check if it's a room name
                if (!newRoomKey) {
                    for (const [dir, targetKey] of Object.entries(room.exits)) {
                        const targetRoom = WORLD[targetKey];
                        // Match against key (e.g. 'server_room') or name (e.g. 'Server Room')
                        if (targetKey.replace('_', ' ').includes(noun) || targetRoom.name.toLowerCase().includes(noun)) {
                            newRoomKey = targetKey;
                            break;
                        }
                    }
                }

                if (newRoomKey) {
                    STATE.currentRoom = newRoomKey;
                    STATE.turn++;
                    Sound.setRoomAmbience(newRoomKey);
                    await printLine(`TRANSIT: ${WORLD[newRoomKey].name.toUpperCase()}`, 'txt-sys');
                    updateUI();
                    await look();
                } else {
                    await printLine("PATH BLOCKED / INVALID.", 'txt-error');
                }
                return;
            }

            if (verb === 'take' || verb === 'grab') {
                const room = WORLD[STATE.currentRoom];
                const itemKey = room.items.find(k => ITEMS[k].name.toLowerCase().includes(noun) || k.includes(noun));
                if (itemKey) {
                    room.items = room.items.filter(k => k !== itemKey);
                    STATE.inventory.push(itemKey);
                    Sound.success();
                    await printLine(`ITEM ACQUIRED: ${ITEMS[itemKey].name}`, 'txt-success');
                    updateUI();
                } else {
                    await printLine("ITEM NOT LOCATED.", 'txt-error');
                }
                return;
            }

            if (verb === 'inspect' || verb === 'check' || verb === 'x') {
                if (!noun) { await printLine("INSPECT WHAT?", 'txt-error'); return; }
                await inspect(noun);
                return;
            }

            if (verb === 'talk' || verb === 'speak') {
                const room = WORLD[STATE.currentRoom];
                // Check primary NPC
                if (room.npc && (room.npc === noun || room.npc.includes(noun))) {
                    await startConversation(room.npc);
                } 
                // Special case: Jax can be talked to in Engineering even though Rook is primary NPC
                else if (noun.includes('jax') && STATE.currentRoom === 'engineering' && CONVERSATIONS['jax']) {
                    await startConversation('jax');
                }
                // Check if any NPC in any room matches
                else {
                    let foundNPC = null;
                    for (const [roomKey, roomData] of Object.entries(WORLD)) {
                        if (roomData.npc && (roomData.npc === noun || roomData.npc.includes(noun))) {
                            foundNPC = roomData.npc;
                            break;
                        }
                    }
                    // Also check conversation keys directly
                    if (!foundNPC && CONVERSATIONS[noun]) {
                        foundNPC = noun;
                    }
                    // Special NPCs that can be talked to by name
                    const specialNPCs = ['aria', 'rook', 'corinne', 'zara', 'thorne', 'voss', 'jax'];
                    if (!foundNPC && specialNPCs.some(npc => npc.includes(noun) || noun.includes(npc))) {
                        foundNPC = specialNPCs.find(npc => npc.includes(noun) || noun.includes(npc));
                    }
                    
                    if (foundNPC && CONVERSATIONS[foundNPC]) {
                        await startConversation(foundNPC);
                } else {
                    await printLine("TARGET NOT PRESENT.", 'txt-error');
                    }
                }
                return;
            }

            if (verb === 'inv') {
                updateUI();
                return;
            }

            if (verb === 'accuse') {
                STATE.mode = 'ACCUSE';
                Sound.error();
                await printLine("!!! FINAL PROTOCOL INITIATED !!!", 'txt-warn text-xl');
                await printLine("You are about to file your final report. This cannot be undone.", 'txt-sys');
                await printLine("Identify the killer: [CORINNE] / [JAX] / [THORNE] / [VOSS] / [ROOK] / [ARIA]", 'txt-success glow-text');
                await printLine("Evidence collected: " + STATE.evidence.size + " pieces", 'txt-sys');
                return;
            }

            await printLine("UNKNOWN COMMAND.", 'txt-error');
        }

        async function handleAccusation(input) {
            STATE.mode = 'END';
            const s = input.toLowerCase();

            printInstant("------------------------------------------------", 'txt-sys');
            await printLine("TRANSMITTING FINAL VERDICT...", 'txt-sys');

            // Check for conspiracy ending
            const hasConspiracyEvidence = STATE.evidence.has("Conspiracy Evidence") && 
                                        STATE.evidence.has("Command Authorization") &&
                                        STATE.evidence.has("Smuggling Operation");

            if (s.includes('corinne')) {
                const hasConfession = STATE.evidence.has("Corinne's Confession");
                const evidenceCount = STATE.evidence.size;
                
                if (hasConfession && evidenceCount >= 5) {
                    // Perfect ending - True Justice
                    Sound.success();
                    await printLine("VERDICT: ACCEPTED.", 'txt-success text-xl font-bold');
                    await printLine("Dr. Corinne was detained. Your comprehensive evidence proved she murdered Vane to protect her research and prevent him from selling A.R.I.A. to the military. Justice served.", 'text-white mt-4');
                    await printLine("MISSION RATING: S", 'txt-success text-2xl');
                    setTimeout(() => showGameOver("S", `EXCELLENT WORK, ${DETECTIVE_NAME.toUpperCase()}. THE STATION IS SECURE.`, "text-green-500"), 4000);
                } else if (hasConfession || evidenceCount >= 3) {
                    // Good ending - Correct Accusation
                    Sound.success();
                    await printLine("VERDICT: ACCEPTED.", 'txt-success text-xl font-bold');
                    await printLine("Dr. Corinne was detained. Your evidence proved she murdered Vane, though some details of the conspiracy remain unclear.", 'text-white mt-4');
                    await printLine("MISSION RATING: A", 'txt-success');
                    setTimeout(() => showGameOver("A", `GOOD WORK, ${DETECTIVE_NAME.toUpperCase()}. CASE SOLVED.`, "text-green-400"), 4000);
                } else {
                    // Neutral ending - Insufficient Evidence
                    await printLine("VERDICT: DISPUTED.", 'txt-warn text-xl font-bold');
                    await printLine("Corinne was arrested, but her lawyers tore your case apart due to lack of concrete evidence. She walked free a month later.", 'text-white mt-4');
                    await printLine("MISSION RATING: C", 'txt-warn');
                     setTimeout(() => showGameOver("C", "CASE COMPROMISED. SUSPECT RELEASED.", "text-yellow-500"), 4000);
                }
            } else if (s.includes('jax')) {
                const hasJaxEvidence = STATE.evidence.has("Jax's Access Log") && 
                                     STATE.evidence.has("Blackmail Evidence") &&
                                     STATE.evidence.has("Override Chip Source");
                
                if (hasJaxEvidence && STATE.evidence.size >= 4) {
                    Sound.success();
                    await printLine("VERDICT: ACCEPTED.", 'txt-success text-xl font-bold');
                    await printLine("Jax was arrested. Evidence shows he was in the Server Room just before the murder, had motive (blackmail), and access to the override chip. However, further investigation reveals he may have been working with others.", 'text-white mt-4');
                    await printLine("MISSION RATING: A", 'txt-success');
                    setTimeout(() => showGameOver("A", `PARTIAL SUCCESS, ${DETECTIVE_NAME.toUpperCase()}. SUSPECT DETAINED.`, "text-green-400"), 4000);
                } else if (hasJaxEvidence) {
                    await printLine("VERDICT: DISPUTED.", 'txt-warn text-xl font-bold');
                    await printLine("Jax was arrested, but the case was weak. He claimed he was framed. The truth remains unclear.", 'text-white mt-4');
                    await printLine("MISSION RATING: C", 'txt-warn');
                    setTimeout(() => showGameOver("C", "CASE WEAK. SUSPECT DISPUTES CHARGES.", "text-yellow-500"), 4000);
                } else {
                    Sound.error();
                    await printLine("VERDICT: ERROR.", 'txt-error text-xl font-bold');
                    await printLine("Insufficient evidence against Jax. He was released, and the real killer remains free.", 'text-white mt-4');
                    await printLine("MISSION RATING: D", 'txt-error');
                    setTimeout(() => showGameOver("D", "INSUFFICIENT EVIDENCE. CASE FAILED.", "text-red-400"), 4000);
                }
            } else if (s.includes('thorne')) {
                const hasThorneEvidence = STATE.evidence.has("Smuggling Operation") &&
                                        STATE.evidence.has("Security Footage");
                
                if (hasThorneEvidence && STATE.evidence.size >= 4) {
                    await printLine("VERDICT: PARTIAL.", 'txt-warn text-xl font-bold');
                    await printLine("Thorne was arrested for smuggling, but evidence suggests he may have been involved in the murder as part of a cover-up. The full truth remains hidden.", 'text-white mt-4');
                    await printLine("MISSION RATING: B", 'txt-warn');
                    setTimeout(() => showGameOver("B", "PARTIAL TRUTH REVEALED. CONSPIRACY SUSPECTED.", "text-yellow-400"), 4000);
                } else {
                    Sound.error();
                    await printLine("VERDICT: ERROR.", 'txt-error text-xl font-bold');
                    await printLine("Thorne was innocent of murder. You arrested the wrong person while the real killer escaped.", 'text-white mt-4');
                    await printLine("MISSION RATING: F", 'txt-error');
                    setTimeout(() => showGameOver("F", "CRITICAL JUDGEMENT ERROR. INNOCENT CONVICTED.", "text-red-500"), 4000);
                }
            } else if (s.includes('voss')) {
                if (hasConspiracyEvidence && STATE.evidence.size >= 6) {
                    Sound.success();
                    await printLine("VERDICT: CONSPIRACY UNCOVERED.", 'txt-success text-xl font-bold');
                    await printLine("Voss was arrested along with Thorne. You uncovered the full conspiracy - they were covering up Project Chimera for corporate interests. Vane's murder was part of the cover-up. The truth is finally exposed.", 'text-white mt-4');
                    await printLine("MISSION RATING: S", 'txt-success text-2xl');
                    setTimeout(() => showGameOver("S", `CONSPIRACY UNCOVERED, ${DETECTIVE_NAME.toUpperCase()}. JUSTICE SERVED.`, "text-green-500"), 4000);
                } else if (STATE.evidence.has("Command Authorization")) {
                    await printLine("VERDICT: DISPUTED.", 'txt-warn text-xl font-bold');
                    await printLine("Voss was questioned but released. Evidence of conspiracy was insufficient. The cover-up continues.", 'text-white mt-4');
                    await printLine("MISSION RATING: C", 'txt-warn');
                    setTimeout(() => showGameOver("C", "CONSPIRACY REMAINS HIDDEN. CASE INCOMPLETE.", "text-yellow-500"), 4000);
                } else {
                    Sound.error();
                    await printLine("VERDICT: ERROR.", 'txt-error text-xl font-bold');
                    await printLine("Insufficient evidence. Voss used her authority to dismiss the charges. The conspiracy remains hidden.", 'text-white mt-4');
                    await printLine("MISSION RATING: D", 'txt-error');
                    setTimeout(() => showGameOver("D", "INSUFFICIENT EVIDENCE. AUTHORITY PROTECTED.", "text-red-400"), 4000);
                }
            } else if (s.includes('rook')) {
                Sound.error();
                await printLine("VERDICT: ERROR.", 'txt-error text-xl font-bold');
                await printLine("Rook was innocent of murder. You sent a man to prison for gambling debts while the real killer escaped.", 'text-white mt-4');
                await printLine("MISSION RATING: F", 'txt-error');
                 setTimeout(() => showGameOver("F", "CRITICAL JUDGEMENT ERROR. INNOCENT CONVICTED.", "text-red-500"), 4000);
            } else if (s.includes('aria')) {
                Sound.error();
                triggerShake();
                await printLine("CRITICAL FAILURE.", 'txt-error text-xl font-bold');
                await printLine("Accusing the AI triggered a failsafe. Station Icarus vented all atmosphere. There were no survivors.", 'text-red-500 mt-4');
                await printLine("MISSION RATING: TERMINATED", 'txt-error');
                 setTimeout(() => showGameOver("TERMINATED", "FATAL SYSTEM ERROR. CREW LOST.", "text-red-600"), 4000);
            } else {
                await printLine("INVALID TARGET. CASE COLD.", 'txt-error');
                 setTimeout(() => showGameOver("FAIL", "SUBMISSION ERROR. SUSPECT UNKNOWN.", "text-gray-500"), 4000);
            }
        }

        function triggerShake() {
            const main = document.querySelector('main');
            main.classList.remove('shake');
            void main.offsetWidth; 
            main.classList.add('shake');
        }

        // --- Boot Sequence ---

        const bootSequence = [
            "Initializing Kernel...",
            "Loading Neural Link...",
            "Connecting to Station Icarus Relay...",
            `Authentication: ${DETECTIVE_NAME.toUpperCase()}`,
            "Secure Connection Established.",
            "",
            "> INCOMING TRANSMISSION <",
            `${DETECTIVE_NAME}, Dr. Silas Vane is dead.`,
            "He was working on illegal AI modifications in the Void Sector.",
            "You have 1 hour before the station's orbit decays.",
            "Find the killer. Secure the data.",
            "Trust no one."
        ];

        async function playBootSequence() {
            for (let line of bootSequence) {
                const p = document.createElement('p');
                p.textContent = line;
                bootText.appendChild(p);
                Sound.blip();
                bootText.scrollTop = bootText.scrollHeight;
                await new Promise(r => setTimeout(r, 600));
            }
            startBtn.classList.remove('opacity-0');
        }

        // --- Event Listeners ---

        startBtn.addEventListener('click', () => {
            Sound.success();
            Sound.setRoomAmbience(STATE.currentRoom);
            landingPage.classList.add('hidden');
            // Initial Look
            look();
        });

        restartBtn.addEventListener('click', () => {
             Sound.success();
             window.location.reload();
        });

        formEl.addEventListener('submit', (e) => {
            e.preventDefault();
            if (isTyping) return;
            const val = inputEl.value;
            inputEl.value = '';
            parseCommand(val);
        });

        // Initialize
        updateUI();
        Sound.init();
        playBootSequence();

    </script>
</body>
</html>